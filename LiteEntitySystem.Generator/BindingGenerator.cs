using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace LiteEntitySystem.Generator
{
    [Generator]
    public class BindingGenerator : ISourceGenerator
    {
        private static readonly StringBuilder ResultCode = new StringBuilder(); 
        
        private static readonly DiagnosticDescriptor NoPartialOnClass = new DiagnosticDescriptor(
            id: "LES001",
            title: "Class derived from SyncableField or InternalEntity must be partial",
            messageFormat: "Class derived from SyncableField or InternalEntity must be partial '{0}'",
            category: "LiteEntitySystem",
            DiagnosticSeverity.Error,
            isEnabledByDefault: true);
        
        private static readonly DiagnosticDescriptor RemoteCallShouldBeStatic = new DiagnosticDescriptor(
            id: "LES002",
            title: "RemoteCall should be static",
            messageFormat: "RemoteCall should be static '{0}'",
            category: "LiteEntitySystem",
            DiagnosticSeverity.Error,
            isEnabledByDefault: true);
        
        private static readonly DiagnosticDescriptor SyncableReadOnly = new DiagnosticDescriptor(
            id: "LES003",
            title: "Syncable fields should be readonly",
            messageFormat: "Syncable fields should be readonly",
            category: "LiteEntitySystem",
            DiagnosticSeverity.Error,
            isEnabledByDefault: true);
        
        private static bool InheritsFrom(INamedTypeSymbol from, ITypeSymbol symbol)
        {
            while (true)
            {
                if (TypeEquals(symbol,from))
                {
                    return true;
                }
                if (symbol.BaseType != null)
                {
                    symbol = symbol.BaseType;
                    continue;
                }
                break;
            }
            return false;
        }

        private static bool TypeEquals(ISymbol x, ISymbol y)
        {
            return SymbolEqualityComparer.Default.Equals(x, y);
        }
        
        private static IEnumerable<ITypeSymbol> GetBaseTypes(ITypeSymbol type)
        {
            var current = type.BaseType;
            while (current != null)
            {
                yield return current;
                current = current.BaseType;
            }
        }
        
        private static IEnumerable<ITypeSymbol> GetBaseTypesIncludeSelf(ITypeSymbol type)
        {
            var current = type.BaseType;
            while (current != null)
            {
                yield return current;
                current = current.BaseType;
            }
            yield return type;
        }

        private static string TAB(int count)
        {
            return new string(' ', count*4);
        }

        public void Execute(GeneratorExecutionContext context)
        {
            var compilation = context.Compilation;
            var baseSyncType = compilation.GetTypeByMetadataName("LiteEntitySystem.Internal.InternalSyncType");
            var internalEntityType = compilation.GetTypeByMetadataName("LiteEntitySystem.Internal.InternalEntity");
            var singletonEntityType = compilation.GetTypeByMetadataName("LiteEntitySystem.SingletonEntity");
            var syncableFieldType = compilation.GetTypeByMetadataName("LiteEntitySystem.SyncableField");
            var bindOnChangeAttribType = compilation.GetTypeByMetadataName("LiteEntitySystem.BindOnChange");
            var syncVarFlagsAttribType = compilation.GetTypeByMetadataName("LiteEntitySystem.SyncVarFlags");
            var localOnlyAttribType = compilation.GetTypeByMetadataName("LiteEntitySystem.LocalOnly");
            var updateableEntityAttribType = compilation.GetTypeByMetadataName("LiteEntitySystem.UpdateableEntity");

            ResultCode.Clear();
            ResultCode.AppendLine(@"// <auto-generated/>
using System;
using System.Runtime.CompilerServices;
using System.Collections.Generic;
using LiteEntitySystem;
using LiteEntitySystem.Internal;");

            Func<IFieldSymbol, bool> correctSyncVarPredicate = x =>
                x.Type.Name == "SyncVar" || InheritsFrom(syncableFieldType, x.Type) || x.Type.Name.StartsWith("RemoteCall");

            var fieldSaveIfDifferentInnerText = new StringBuilder();
            var fieldLoadIfDifferentInnerText = new StringBuilder();
            var fieldSaveInnerText = new StringBuilder();
            var fieldLoadInnerText = new StringBuilder();
            var fieldLoadHistoryInnerText = new StringBuilder();
            var fieldSetInterpolationInnerText = new StringBuilder();
            var fieldOnChangeInnerText = new StringBuilder();
            var syncablesInitInnerText = new StringBuilder();
            var syncablesResyncInnerText = new StringBuilder();
            var syncablesSetIdInnerText = new StringBuilder();
            var syncablesGetByIdText = new StringBuilder();
            var remoteCallsSetIdText = new StringBuilder();
            var classMetadataText = new StringBuilder();
            
            foreach (var syntaxTree in compilation.SyntaxTrees)
            {
                var semanticModel = compilation.GetSemanticModel(syntaxTree);
                foreach (var classDeclarationSyntax in syntaxTree.GetRoot().DescendantNodesAndSelf().OfType<ClassDeclarationSyntax>())
                {
                    var classSymbol = ModelExtensions.GetDeclaredSymbol(semanticModel, classDeclarationSyntax) as INamedTypeSymbol;
                    
                    //skip not entities
                    if(classSymbol == null || !InheritsFrom(baseSyncType, classSymbol))
                        continue;
                    
                    var currentSyncVars = classSymbol
                        .GetMembers()
                        .OfType<IFieldSymbol>()
                        .Where(correctSyncVarPredicate);
                    
                    //skip empty
                    if (!currentSyncVars.Any())
                        continue;
                    
                    if (!classDeclarationSyntax.Modifiers.Any(m => m.IsKind(SyntaxKind.PartialKeyword)))
                    {
                        context.ReportDiagnostic(Diagnostic.Create(NoPartialOnClass, classSymbol.Locations[0], classSymbol.Name));
                        continue;
                    }
                    
                    fieldSaveIfDifferentInnerText.Clear();
                    fieldLoadIfDifferentInnerText.Clear();
                    fieldSaveInnerText.Clear();
                    fieldLoadInnerText.Clear();
                    fieldLoadHistoryInnerText.Clear();
                    fieldSetInterpolationInnerText.Clear();
                    fieldOnChangeInnerText.Clear();
                    syncablesInitInnerText.Clear();
                    syncablesResyncInnerText.Clear();
                    syncablesSetIdInnerText.Clear();
                    syncablesGetByIdText.Clear();
                    remoteCallsSetIdText.Clear();
                    classMetadataText.Clear();
                    
                    //classMetadataText.AppendLine(classSymbol.GetAttributes().Any(x => TypeEquals(x.AttributeClass, localOnlyAttribType))
                    //    ? $"{TAB(4)}classMetadata.IsLocalOnly = true;"
                    //    : $"{TAB(4)}classMetadata.IsLocalOnly = baseClassMetadata.IsLocalOnly;");

                    var updatableAttrib = classSymbol.GetAttributes()
                        .FirstOrDefault(x => TypeEquals(x.AttributeClass, updateableEntityAttribType));
                    if (updatableAttrib != null)
                    {
                        classMetadataText.AppendLine($"{TAB(4)}classMetadata.IsUpdateable = true;");
                        TypedConstant? arg = updatableAttrib.ConstructorArguments.FirstOrDefault();
                        if (arg.HasValue && arg.Value.Value != null)
                        {
                            classMetadataText.AppendLine($"{TAB(4)}classMetadata.UpdateOnClient = {arg.Value.Value.ToString().ToLower()};");
                        }
                        else
                        {
                            classMetadataText.AppendLine($"{TAB(4)}classMetadata.UpdateOnClient = false;");
                        }
                    }
                    else
                    {
                        classMetadataText.AppendLine($"{TAB(4)}classMetadata.IsUpdateable = baseClassMetadata.IsUpdateable;");
                        classMetadataText.AppendLine($"{TAB(4)}classMetadata.UpdateOnClient = baseClassMetadata.UpdateOnClient;");
                    }
                    
                    string genericArgs = string.Empty;
                    if (classSymbol.IsGenericType)
                    {
                        genericArgs = "<";
                        for(int i = 0; i < classSymbol.TypeArguments.Length; i++)
                        {
                            genericArgs += $"{classSymbol.TypeArguments[i]}";
                            if (i < classSymbol.TypeArguments.Length - 1)
                                genericArgs += ",";
                        }
                        genericArgs += ">";
                    }
                    string className = classSymbol.Name + genericArgs;

                    string fieldIdString = InheritsFrom(syncableFieldType, classSymbol) ? "field.SyncableId - MetadataCache.BaseSyncablesCount" : "field.Id - MetadataCache.BaseFieldsCount";
                    string internalAddition = classSymbol.ContainingNamespace.ToString().StartsWith("LiteEntitySystem") 
                        ? " internal" 
                        : string.Empty;

                    int fieldId = 0;
                    int syncableId = 0;
                    int rpcId = 0;
                    
                    foreach (var fieldSymbol in currentSyncVars)
                    {
                        string fieldName = $"_target.{fieldSymbol.Name}";
                        
                        if (fieldSymbol.Type.Name.StartsWith("RemoteCall"))
                        {
                            if (!fieldSymbol.IsStatic)
                                context.ReportDiagnostic(Diagnostic.Create(RemoteCallShouldBeStatic, fieldSymbol.Locations[0], fieldSymbol.Name));
                            remoteCallsSetIdText.Append($"\n        CodeGenUtils.SetRemoteCallId(ref {fieldSymbol.Name}, {rpcId});");
                            rpcId++;
                            continue;
                        }
                        
                        string caseString = @$"
{TAB(4)}case {fieldId}:";
                        fieldSaveIfDifferentInnerText.Append(caseString);
                        fieldLoadIfDifferentInnerText.Append(caseString);
                        fieldSaveInnerText.Append(caseString);
                        fieldLoadInnerText.Append(caseString);
                        fieldLoadHistoryInnerText.Append(caseString);
                        fieldSetInterpolationInnerText.Append(caseString);
                        
                        var syncVarFlagsAttr = fieldSymbol.GetAttributes().FirstOrDefault(x =>
                            TypeEquals(x.AttributeClass, syncVarFlagsAttribType));
                        string syncFlagsStr = syncVarFlagsAttr != null
                            ? "(SyncFlags)" + syncVarFlagsAttr.ConstructorArguments.First().Value
                            : "SyncFlags.None";
                        
                        //if syncableField
                        if (InheritsFrom(syncableFieldType, fieldSymbol.Type))
                        {
                            if (!fieldSymbol.IsReadOnly)
                            {
                                context.ReportDiagnostic(Diagnostic.Create(SyncableReadOnly, fieldSymbol.Locations[0]));
                            }
                            classMetadataText.AppendLine($"{TAB(4)}classMetadata.AddSyncableField(fields, {fieldSymbol.Type}.MetadataCache);");
                            fieldSaveIfDifferentInnerText.Append($" return CodeGenUtils.GetFieldManipulator({fieldName}).SaveIfDifferent(in field, data);");
                            fieldLoadIfDifferentInnerText.Append($" return CodeGenUtils.GetFieldManipulator({fieldName}).LoadIfDifferent(in field, data);");
                            fieldSaveInnerText.Append($" CodeGenUtils.GetFieldManipulator({fieldName}).Save(in field, data); break;");
                            fieldLoadInnerText.Append($" CodeGenUtils.GetFieldManipulator({fieldName}).Load(in field, data); break;");
                            fieldLoadHistoryInnerText.Append($" CodeGenUtils.GetFieldManipulator({fieldName}).LoadHistory(in field, tempHistory, historyA, historyB, lerpTime); break;");
                            fieldSetInterpolationInnerText.Append($" CodeGenUtils.GetFieldManipulator({fieldName}).SetInterpolation(in field, prev, current, fTimer); break;");
                            syncablesInitInnerText.Append($"\n        CodeGenUtils.RegisterRPC({fieldName});");
                            syncablesResyncInnerText.Append($"\n{TAB(3)}CodeGenUtils.OnSyncRequested({fieldSymbol.Name});");
                            syncablesSetIdInnerText.Append($"\n        CodeGenUtils.InternalSyncablesSetup({fieldName}, this, {rpcId});");
                            syncablesGetByIdText.Append($"\n{TAB(3)}case {syncableId}: return {fieldSymbol.Name};");
                            syncableId++;
                        }
                        else
                        {   
                            string hasChangeNotify = fieldSymbol.GetAttributes()
                                .Any(x => TypeEquals(x.AttributeClass, bindOnChangeAttribType))
                                ? "true"
                                : "false";
                            var syncVarGenericArg = ((INamedTypeSymbol)fieldSymbol.Type).TypeArguments[0];
                            
                            if(InheritsFrom(classSymbol, syncableFieldType))
                                classMetadataText.AppendLine($"{TAB(4)}classMetadata.AddField<{syncVarGenericArg}>(new EntityFieldInfo(\"{fieldSymbol.Name}\", typeof({syncVarGenericArg}), (ushort)(fields.Count), {syncFlagsStr}), fields, lagCompensatedFields);");
                            else
                                classMetadataText.AppendLine($"{TAB(4)}classMetadata.AddField<{syncVarGenericArg}>(new EntityFieldInfo(\"{fieldSymbol.Name}\", typeof({syncVarGenericArg}), (ushort)(fields.Count), {syncFlagsStr}, {hasChangeNotify}), fields, lagCompensatedFields);");
                            
                            string dotValueText = classSymbol.TypeArguments.Contains(syncVarGenericArg) ? string.Empty : ".Value";
                            
                            fieldSaveIfDifferentInnerText.Append(@$"   
                    if({fieldName}{dotValueText} != Helpers.ReadStruct<{syncVarGenericArg}>(data))       
                    {{
                        Helpers.WriteStruct(data, {fieldName}.Value);
                        return true;
                    }}
                    return false;");
                            
                            fieldLoadIfDifferentInnerText.Append(@$"
                    var {fieldSymbol.Name}Stored = Helpers.ReadStruct<{syncVarGenericArg}>(data);
                    if({fieldName}{dotValueText} != {fieldSymbol.Name}Stored)
                    {{
                        {fieldName}.Value = {fieldSymbol.Name}Stored;
                        return true;
                    }}
                    return false;");
                            
                            fieldSaveInnerText.Append($" Helpers.WriteStruct(data, {fieldName}.Value); break;");
                            fieldLoadInnerText.Append($" Helpers.ReadStruct(data, out {fieldName}.Value); break;");
                            fieldLoadHistoryInnerText.Append(@$"        
                    tempHistory.WriteStruct({fieldName}.Value);
                    {fieldName}.Value = ValueTypeProcessor<{syncVarGenericArg}>.InterpDelegate != null
                        ? ValueTypeProcessor<{syncVarGenericArg}>.InterpDelegate(historyA.ReadStruct<{syncVarGenericArg}>(), historyB.ReadStruct<{syncVarGenericArg}>(), lerpTime)
                        : historyA.ReadStruct<{syncVarGenericArg}>();
                    break;");
                            fieldSetInterpolationInnerText.Append(@$"        
                    if(ValueTypeProcessor<{syncVarGenericArg}>.InterpDelegate == null) throw new Exception(""This type: {syncVarGenericArg} can't be interpolated"");
                    {fieldName}.Value = ValueTypeProcessor<{syncVarGenericArg}>.InterpDelegate(prev.ReadStruct<{syncVarGenericArg}>(), current.ReadStruct<{syncVarGenericArg}>(), fTimer);
                    break;");

                            var bindOnChangeAttr = fieldSymbol.GetAttributes().FirstOrDefault(x => TypeEquals(x.AttributeClass, bindOnChangeAttribType));
                            if (bindOnChangeAttr != null)
                            {
                                //TODO: error when signature differs
                                fieldOnChangeInnerText.Append($"{caseString} _target.{bindOnChangeAttr.ConstructorArguments[0].Value}(prevData.ReadStruct<{syncVarGenericArg}>()); break;");
                            }
                        }
                        
                        fieldId++;
                    }

                    string syncablesPart = InheritsFrom(syncableFieldType, classSymbol) || TypeEquals(internalEntityType, classSymbol)
                        ? string.Empty
                        : $@"
        protected{internalAddition} override SyncableField InternalGetSyncableFieldById(int id)
        {{
            switch(id)
            {{{syncablesGetByIdText}
            default: return base.InternalGetSyncableFieldById(id);
            }}
        }} 

        protected{internalAddition} override void InternalSyncablesResync() 
        {{
            base.InternalSyncablesResync();{syncablesResyncInnerText}
        }}";
                    if (!classSymbol.ContainingNamespace.IsGlobalNamespace)
                        ResultCode.Append($@"
namespace {classSymbol.ContainingNamespace}
{{");

                    bool baseTypeIsSimple =
                        TypeEquals(classSymbol.BaseType, syncableFieldType) ||
                        TypeEquals(classSymbol.BaseType, baseSyncType);
                    
                    string baseFieldManipulator = baseTypeIsSimple
                        ? "FieldManipulator"
                        : $"{classSymbol.BaseType.Name}FieldManipulator";
                    string baseConstructorCall = baseTypeIsSimple
                        ? string.Empty
                        : " : base(target)";
                    string baseclassMetadata = baseTypeIsSimple
                        ? "new GeneratedClassMetadata()"
                        : $"{classSymbol.BaseType.Name}.CreateMetadata()";
                    string newAddition = baseTypeIsSimple
                        ? string.Empty
                        : " new";
                    
                    ResultCode.Append($@"

    partial class {className}
    {{
        protected class {classSymbol.Name}FieldManipulator : {baseFieldManipulator}
        {{
            private {className} _target;

            public {classSymbol.Name}FieldManipulator({className} target){baseConstructorCall}
            {{
                _target = target;
            }}

            public override bool SaveIfDifferent(in EntityFieldInfo field, Span<byte> data)
            {{
                switch({fieldIdString})
                {{{fieldSaveIfDifferentInnerText}
                default: return base.SaveIfDifferent(in field, data);
                }}
            }}

            public override bool LoadIfDifferent(in EntityFieldInfo field, ReadOnlySpan<byte> data)
            {{
                switch({fieldIdString})
                {{{fieldLoadIfDifferentInnerText}
                default: return base.LoadIfDifferent(in field, data);
                }}
            }}

            public override void Save(in EntityFieldInfo field, Span<byte> data)
            {{
                switch({fieldIdString})
                {{{fieldSaveInnerText}
                default: base.Save(in field, data); break;
                }}
            }}

            public override void Load(in EntityFieldInfo field, ReadOnlySpan<byte> data)
            {{
                switch({fieldIdString})
                {{{fieldLoadInnerText}
                default: base.Load(in field, data); break;
                }}
            }}

            public override void LoadHistory(in EntityFieldInfo field, Span<byte> tempHistory, ReadOnlySpan<byte> historyA, ReadOnlySpan<byte> historyB, float lerpTime)
            {{
                switch({fieldIdString})
                {{{fieldLoadHistoryInnerText}
                default: base.LoadHistory(in field, tempHistory, historyA, historyB, lerpTime); break;
                }}
            }}

            public override void SetInterpolation(in EntityFieldInfo field, ReadOnlySpan<byte> prev, ReadOnlySpan<byte> current, float fTimer)
            {{
                switch({fieldIdString})
                {{{fieldSetInterpolationInnerText}
                default: base.SetInterpolation(in field, prev, current, fTimer); break;
                }}
            }}

            public override void OnChange(in EntityFieldInfo field, ReadOnlySpan<byte> prevData)
            {{
                switch({fieldIdString})
                {{{fieldOnChangeInnerText}
                default: base.OnChange(in field, prevData); break;
                }}
            }}
        }}

        private {classSymbol.Name}FieldManipulator _fieldManipulator;
        private static readonly GeneratedClassMetadata MetadataCache = CreateMetadata();

        protected static{newAddition} GeneratedClassMetadata CreateMetadata()
        {{
            ref var classMetadata = ref GeneratedClassDataHandler<{className}>.ClassMetadata;
            if (classMetadata == null)
            {{
                var baseClassMetadata = {baseclassMetadata};
                classMetadata = new GeneratedClassMetadata(baseClassMetadata);
                var fields = new List<EntityFieldInfo>(baseClassMetadata.Fields);
                var lagCompensatedFields = new List<EntityFieldInfo>(baseClassMetadata.LagCompensatedFields);
{classMetadataText}
                fields.Sort((a, b) =>
                {{
                    int wa = a.Flags.HasFlagFast(SyncFlags.Interpolated) ? 1 : 0;
                    int wb = b.Flags.HasFlagFast(SyncFlags.Interpolated) ? 1 : 0;
                    return wb - wa;
                }});
                classMetadata.Fields = fields.ToArray();
                classMetadata.FieldsCount = fields.Count;
                classMetadata.LagCompensatedFields = lagCompensatedFields.ToArray();
                classMetadata.LagCompensatedCount = lagCompensatedFields.Count;
                classMetadata.FieldsFlagsSize = (fields.Count-1) / 8 + 1;

                int fixedOffset = 0;
                int predictedOffset = 0;
                for (int i = 0; i < classMetadata.Fields.Length; i++)
                {{
                    ref var field = ref classMetadata.Fields[i];
                    field.FixedOffset = fixedOffset;
                    fixedOffset += field.IntSize;
                    if (field.IsPredicted)
                    {{
                        field.PredictedOffset = predictedOffset;
                        predictedOffset += field.IntSize;
                    }}
                    else
                    {{
                        field.PredictedOffset = -1;
                    }}
                }}
            }}
            return classMetadata;
        }}

        protected{internalAddition} override FieldManipulator GetFieldManipulator()
        {{
            return _fieldManipulator ??= new {classSymbol.Name}FieldManipulator(this);
        }}

        protected{internalAddition} override GeneratedClassMetadata GetClassMetadata()
        {{
            return MetadataCache;
        }}
{syncablesPart}
    }}");
                    if (!classSymbol.ContainingNamespace.IsGlobalNamespace)
                        ResultCode.AppendLine("}");
                    else
                        ResultCode.AppendLine();
                }
            }
            
            context.AddSource("LiteEntitySystemBindings.g.cs", ResultCode.ToString());
        }

        public void Initialize(GeneratorInitializationContext context) { }
    }
}