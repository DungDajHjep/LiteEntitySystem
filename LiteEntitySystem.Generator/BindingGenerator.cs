using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace LiteEntitySystem.Generator
{
    [Generator]
    public class BindingGenerator : ISourceGenerator
    {
        private static readonly StringBuilder ResultCode = new StringBuilder(); 
        
        private static readonly DiagnosticDescriptor NoPartialOnClass = new DiagnosticDescriptor(
            id: "LES001",
            title: "Class derived from SyncableField or InternalEntity must be partial",
            messageFormat: "Class derived from SyncableField or InternalEntity must be partial '{0}'",
            category: "LiteEntitySystem",
            DiagnosticSeverity.Warning,
            isEnabledByDefault: true);
        
        private static bool InheritsFrom(INamedTypeSymbol from, ITypeSymbol symbol)
        {
            while (true)
            {
                if (SymbolEqualityComparer.Default.Equals(symbol,from))
                {
                    return true;
                }
                if (symbol.BaseType != null)
                {
                    symbol = symbol.BaseType;
                    continue;
                }
                break;
            }
            return false;
        }
        
        private static IEnumerable<ITypeSymbol> GetBaseTypes(ITypeSymbol type)
        {
            var current = type.BaseType;
            while (current != null)
            {
                yield return current;
                current = current.BaseType;
            }
        }

        public void Execute(GeneratorExecutionContext context)
        {
            var compilation = context.Compilation;
            var baseSyncType = compilation.GetTypeByMetadataName("LiteEntitySystem.Internal.InternalSyncType");
            var internalEntityType = compilation.GetTypeByMetadataName("LiteEntitySystem.Internal.InternalEntity");
            var syncableFieldType = compilation.GetTypeByMetadataName("LiteEntitySystem.SyncableField");
            var bindOnChangeAttribType = compilation.GetTypeByMetadataName("LiteEntitySystem.BindOnChange");

            ResultCode.Clear();
            ResultCode.AppendLine(@"// <auto-generated/>
using System;
using System.Runtime.CompilerServices;
using LiteEntitySystem;
using LiteEntitySystem.Internal;");

            Func<IFieldSymbol, bool> correctSyncVarPredicate = x =>
                (x.Type.Name == "SyncVar" || InheritsFrom(syncableFieldType, x.Type)) && !x.IsStatic;

            var fieldSaveIfDifferentInnerText = new StringBuilder();
            var fieldLoadIfDifferentInnerText = new StringBuilder();
            var fieldSaveInnerText = new StringBuilder();
            var fieldLoadInnerText = new StringBuilder();
            var fieldLoadHistoryInnerText = new StringBuilder();
            var fieldSetInterpolationInnerText = new StringBuilder();
            var fieldOnChangeInnerText = new StringBuilder();
            var syncablesInitInnerText = new StringBuilder();
            var syncablesResyncInnerText = new StringBuilder();
            var syncablesSetIdInnerText = new StringBuilder();
            
            foreach (var syntaxTree in compilation.SyntaxTrees)
            {
                var semanticModel = compilation.GetSemanticModel(syntaxTree);
                foreach (var classDeclarationSyntax in syntaxTree.GetRoot().DescendantNodesAndSelf().OfType<ClassDeclarationSyntax>())
                {
                    var classSymbol = ModelExtensions.GetDeclaredSymbol(semanticModel, classDeclarationSyntax) as INamedTypeSymbol;
                    if(classSymbol == null || (!InheritsFrom(baseSyncType, classSymbol)))
                        continue;
                    var currentSyncVars = classSymbol
                        .GetMembers()
                        .Reverse()
                        .OfType<IFieldSymbol>()
                        .Where(correctSyncVarPredicate);
                    
                    //skip empty
                    if (!currentSyncVars.Any())
                        continue;
                    if (!classDeclarationSyntax.Modifiers.Any(m => m.IsKind(SyntaxKind.PartialKeyword)))
                    {
                        context.ReportDiagnostic(Diagnostic.Create(NoPartialOnClass, Location.None, classSymbol.Name));
                        continue;
                    }

                    fieldSaveIfDifferentInnerText.Clear();
                    fieldLoadIfDifferentInnerText.Clear();
                    fieldSaveInnerText.Clear();
                    fieldLoadInnerText.Clear();
                    fieldLoadHistoryInnerText.Clear();
                    fieldSetInterpolationInnerText.Clear();
                    fieldOnChangeInnerText.Clear();
                    
                    int fieldId = GetBaseTypes(classSymbol)
                        .SelectMany(x => x.GetMembers())
                        .OfType<IFieldSymbol>()
                        .Count(correctSyncVarPredicate);
                    
                    string genericArgs = string.Empty;
                    if (classSymbol.IsGenericType)
                    {
                        genericArgs = "<";
                        for(int i = 0; i < classSymbol.TypeArguments.Length; i++)
                        {
                            genericArgs += $"{classSymbol.TypeArguments[i]}";
                            if (i < classSymbol.TypeArguments.Length - 1)
                                genericArgs += ",";
                        }
                        genericArgs += ">";
                    }

                    string fieldIdString = InheritsFrom(syncableFieldType, classSymbol) ? "field.SyncableId" : "field.Id";
                    string internalAddition = classSymbol.ContainingNamespace.ToString().StartsWith("LiteEntitySystem") 
                        ? " internal" 
                        : string.Empty;
                    
                    foreach (var fieldSymbol in currentSyncVars)
                    {
                        string caseString = @$"
      case {fieldId}:";
                        fieldSaveIfDifferentInnerText.Append(caseString);
                        fieldLoadIfDifferentInnerText.Append(caseString);
                        fieldSaveInnerText.Append(caseString);
                        fieldLoadInnerText.Append(caseString);
                        fieldLoadHistoryInnerText.Append(caseString);
                        fieldSetInterpolationInnerText.Append(caseString);
                        
                        //if syncableField
                        if (InheritsFrom(syncableFieldType, fieldSymbol.Type))
                        {
                            fieldSaveIfDifferentInnerText.Append($" return CodeGenUtils.FieldSaveIfDifferent({fieldSymbol.Name}, in field, data);");
                            fieldLoadIfDifferentInnerText.Append($" return CodeGenUtils.FieldLoadIfDifferent({fieldSymbol.Name}, in field, data);");
                            fieldSaveInnerText.Append($" CodeGenUtils.FieldSave({fieldSymbol.Name}, in field, data); break;");
                            fieldLoadInnerText.Append($" CodeGenUtils.FieldLoad({fieldSymbol.Name}, in field, data); break;");
                            fieldLoadHistoryInnerText.Append($" CodeGenUtils.FieldLoadHistory({fieldSymbol.Name}, in field, tempHistory, historyA, historyB, lerpTime); break;");
                            fieldSetInterpolationInnerText.Append($" CodeGenUtils.FieldSetInterpolation({fieldSymbol.Name}, in field, prev, current, fTimer); break;");
                            syncablesInitInnerText.Append($"\n      CodeGenUtils.RegisterRPC({fieldSymbol.Name}, this);");
                            syncablesResyncInnerText.Append($"\n      CodeGenUtils.OnSyncRequested({fieldSymbol.Name});");
                            syncablesSetIdInnerText.Append($"\n      {fieldSymbol.Name}.ParentEntityId = Id;");
                        }
                        else
                        {   
                            var syncVarGenericArg = ((INamedTypeSymbol)fieldSymbol.Type).TypeArguments[0];
                            string dotValueText = classSymbol.TypeArguments.Contains(syncVarGenericArg) ? string.Empty : ".Value";
                            
                            fieldSaveIfDifferentInnerText.Append(@$"   
        if({fieldSymbol.Name}{dotValueText} != Helpers.ReadStruct<{syncVarGenericArg}>(data))       
        {{
          Helpers.WriteStruct(data, {fieldSymbol.Name}.Value);
          return true;
        }}
        return false;");
                            
                            fieldLoadIfDifferentInnerText.Append(@$"
        var {fieldSymbol.Name}Stored = Helpers.ReadStruct<{syncVarGenericArg}>(data);
        if({fieldSymbol.Name}{dotValueText} != {fieldSymbol.Name}Stored)
        {{
          {fieldSymbol.Name}.Value = {fieldSymbol.Name}Stored;
          return true;
        }}
        return false;");
                            
                            fieldSaveInnerText.Append($" Helpers.WriteStruct(data, {fieldSymbol.Name}.Value); break;");
                            fieldLoadInnerText.Append($" Helpers.ReadStruct(data, out {fieldSymbol.Name}.Value); break;");
                            fieldLoadHistoryInnerText.Append(@$"        
        tempHistory.WriteStruct({fieldSymbol.Name}.Value);
        {fieldSymbol.Name}.Value = ValueTypeProcessor<{syncVarGenericArg}>.InterpDelegate != null
          ? ValueTypeProcessor<{syncVarGenericArg}>.InterpDelegate(historyA.ReadStruct<{syncVarGenericArg}>(), historyB.ReadStruct<{syncVarGenericArg}>(), lerpTime)
          : historyA.ReadStruct<{syncVarGenericArg}>();
        break;");
                            fieldSetInterpolationInnerText.Append(@$"        
        if(ValueTypeProcessor<{syncVarGenericArg}>.InterpDelegate == null) throw new Exception(""This type: {syncVarGenericArg} can't be interpolated"");
        {fieldSymbol.Name}.Value = ValueTypeProcessor<{syncVarGenericArg}>.InterpDelegate(prev.ReadStruct<{syncVarGenericArg}>(), current.ReadStruct<{syncVarGenericArg}>(), fTimer);
        break;");

                            var bindOnChangeAttr = fieldSymbol.GetAttributes().FirstOrDefault(x =>
                                SymbolEqualityComparer.Default.Equals(x.AttributeClass, bindOnChangeAttribType));
                            if (bindOnChangeAttr != null)
                            {
                                //TODO: error when signature differs
                                fieldOnChangeInnerText.Append($"{caseString} {bindOnChangeAttr.ConstructorArguments[0].Value}(prevData.ReadStruct<{syncVarGenericArg}>()); break;");
                            }
                        }
                        fieldId++;
                    }

                    string syncablesPart = InheritsFrom(syncableFieldType, classSymbol) || SymbolEqualityComparer.Default.Equals(internalEntityType, classSymbol)
                        ? string.Empty
                        : $@"
    protected{internalAddition} override void InternalSyncablesResync() 
    {{{syncablesResyncInnerText}
    }}

    protected{internalAddition} override void InternalSyncablesInit() 
    {{{syncablesInitInnerText}
    }}

    protected{internalAddition} override void InternalSyncablesSetId()
    {{{syncablesSetIdInnerText}
    }}";
                    if (!classSymbol.ContainingNamespace.IsGlobalNamespace)
                        ResultCode.Append($@"
namespace {classSymbol.ContainingNamespace}
{{");
                    
                    ResultCode.Append($@"
  partial class {classSymbol.Name}{genericArgs}
  {{
    protected{internalAddition} override bool FieldSaveIfDifferent(in EntityFieldInfo field, Span<byte> data)
    {{
      switch({fieldIdString})
      {{{fieldSaveIfDifferentInnerText}
      default: return base.FieldSaveIfDifferent(in field, data);
      }}
    }}

    protected{internalAddition} override bool FieldLoadIfDifferent(in EntityFieldInfo field, ReadOnlySpan<byte> data)
    {{
      switch({fieldIdString})
      {{{fieldLoadIfDifferentInnerText}
      default: return base.FieldLoadIfDifferent(in field, data);
      }}
    }}

    protected{internalAddition} override void FieldSave(in EntityFieldInfo field, Span<byte> data)
    {{
      switch({fieldIdString})
      {{{fieldSaveInnerText}
      default: base.FieldSave(in field, data); break;
      }}
    }}

    protected{internalAddition} override void FieldLoad(in EntityFieldInfo field, ReadOnlySpan<byte> data)
    {{
      switch({fieldIdString})
      {{{fieldLoadInnerText}
      default: base.FieldLoad(in field, data); break;
      }}
    }}

    protected{internalAddition} override void FieldLoadHistory(in EntityFieldInfo field, Span<byte> tempHistory, ReadOnlySpan<byte> historyA, ReadOnlySpan<byte> historyB, float lerpTime)
    {{
      switch({fieldIdString})
      {{{fieldLoadHistoryInnerText}
      default: base.FieldLoadHistory(in field, tempHistory, historyA, historyB, lerpTime); break;
      }}
    }}

    protected{internalAddition} override void FieldSetInterpolation(in EntityFieldInfo field, ReadOnlySpan<byte> prev, ReadOnlySpan<byte> current, float fTimer)
    {{
      switch({fieldIdString})
      {{{fieldSetInterpolationInnerText}
      default: base.FieldSetInterpolation(in field, prev, current, fTimer); break;
      }}
    }}

    protected{internalAddition} override void FieldOnChange(in EntityFieldInfo field, ReadOnlySpan<byte> prevData)
    {{
      switch({fieldIdString})
      {{{fieldOnChangeInnerText}
      default: base.FieldOnChange(in field, prevData); break;
      }}
    }}
{syncablesPart}
  }}");
                    if (!classSymbol.ContainingNamespace.IsGlobalNamespace)
                        ResultCode.AppendLine("}");
                    else
                        ResultCode.AppendLine();
                }
            }
            
            context.AddSource("LiteEntitySystemBindings.g.cs", ResultCode.ToString());
        }

        public void Initialize(GeneratorInitializationContext context) { }
    }
}